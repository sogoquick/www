  nohup /mnt/Nand3/H2000G >/dev/null 2>&1 &
     对
    于& 1 更准确的说应该是文件描述符 1,而1
    一般代表的就是STDOUT_FILENO,实际上这个操作就是一个dup2(2)调用.他标准输出到all_result
    ,然后复制标准输出到文件描述符2(STDERR_FILENO),其后果就是文件描述符1和2指向同一个文件表项,也可以说错误的输出被合并了.其中0
    表示键盘输入 1表示屏幕输出
    2表示错误输出.把标准出错重定向到标准输出,然后扔到/DEV/NULL下面去。通俗的说，就是把所有标准输出和标准出错都扔到垃圾桶里面。
     command >out.file 2>&1 &
     command
    >out.file是将command的输出重定向到out.file文件，即输出内容不打印到屏幕上，而是输出到out.file文件中。
    2>&1
    是将标准出错重定向到标准输出，这里的标准输出已经重定向到了out.file文件，即将标准出错也输出到out.file文件中。最后一个&
    ， 是让该命令在后台执行。
    
     试想2>1代表什么，2与>结合代表错误重定向，而1则代表错误重定向到一个文件1，而不代表标准输出；
    换成2>&1，&与1结合就代表标准输出了，就变成错误重定向到标准输出.
     你可以用
     ls 2>1测试一下，不会报没有2文件的错误，但会输出一个空的文件1；
     ls xxx 2>1测试，没有xxx这个文件的错误输出到了1中；
     ls xxx 2>&1测试，不会生成1这个文件了，不过错误跑到标准输出了；
     ls xxx >out.txt 2>&1, 实际上可换成 ls xxx 1>out.txt 2>&1；重定向符号>默认是1,错误和输出都传到out.txt了。
     为何2>&1要写在后面？
     command > file 2>&1
     首先是command > file将标准输出重定向到file中， 2>&1 是标准错误拷贝了标准输出的行为，也就是同样被重定向到file中，最终结果就是标准输出和错误都被重定向到file中。
     command 2>&1 >file
     2>&1 标准错误拷贝了标准输出的行为，但此时标准输出还是在终端。>file 后输出才被重定向到file，但标准错误仍然保持在终端。
    用strace可以看到：
    1. command > file 2>&1
    这个命令中实现重定向的关键系统调用序列是：
    open(file) == 3
    dup2(3,1)
    dup2(1,2)
    2. command 2>&1 >file
    这个命令中实现重定向的关键系统调用序列是：
    dup2(1,2)
    open(file) == 3
    dup2(3,1)
    可以考虑一下不同的dup2()调用序列会产生怎样的文件共享结构。请参考APUE 3.10, 3.12
